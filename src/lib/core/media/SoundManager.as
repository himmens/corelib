package lib.core.media{import com.gskinner.motion.GTween;import com.gskinner.motion.plugins.SoundTransformPlugin;import flash.events.ErrorEvent;import flash.events.IOErrorEvent;import flash.media.Sound;import flash.media.SoundChannel;import flash.media.SoundLoaderContext;import flash.media.SoundTransform;import flash.net.URLRequest;import flash.system.Capabilities;import flash.utils.Dictionary;import lib.core.util.log.Logger;
public class SoundManager{	// singleton instance	private static var _instance:SoundManager;	protected var _soundsDict:Dictionary;	protected var _sounds:Array;	protected var _available:Boolean = true;	public function get available():Boolean{return _available}	// singleton instance of SoundManager	public static function get instance():SoundManager	{		return SoundManager._instance;	}	public function SoundManager()	{		if(!_instance)		{			_instance = this;			init();		}		else		{			throw(new Error("Only one instance of SoundManager is allowed"));		}	}	protected function init():void	{		_soundsDict = new Dictionary(true);		_sounds = new Array();	}	/**	 * Adds an external sound to the sounds dictionary for playing in the future.	 *	 * @param path A string representing the path where the sound is on the server	 * @param name The string identifier of the sound to be used when calling other methods on the sound	 * @param type The sound type (background, interface, etc..) it's used in child manager implementations	 * @param buffer The number, in milliseconds, to buffer the sound before you can play it (default: 1000)	 * @param checkPolicyFile A boolean that determines whether Flash Player should try to download a cross-domain policy file from the loaded sound's server before beginning to load the sound (default: false)	 *	 * @return Boolean A boolean value representing if the sound was added successfully	 */	public function addExternalSound(path:String, name:String, type:int= 0, buffer:Number = 1000, checkPolicyFile:Boolean = false):Boolean	{		if(_soundsDict[name])			return false;		var snd:Sound = new Sound(new URLRequest(path), new SoundLoaderContext(buffer, checkPolicyFile));		addLibrarySound(name, snd, type);		return true;	}	/**	 * Adds a sound from the library to the sounds dictionary for playing in the future.	 *	 * @param snd The Sound object to add	 * @param name The string identifier of the sound to be used when calling other methods on the sound	 *	 * @return Boolean A boolean value representing if the sound was added successfully	 */	public function addLibrarySound(name:String, snd:Sound, type:int = 0):Boolean	{		if(_soundsDict[name])			return false;		var sndObj:Object = new Object();		snd.addEventListener(IOErrorEvent.IO_ERROR, onLoadError, false, 0, true);		sndObj.name = name;		sndObj.sound = snd;		sndObj.channel = new SoundChannel();		sndObj.position = 0;		sndObj.paused = true;		sndObj.volume = volume;		sndObj.startTime = 0;		sndObj.loops = 0;		sndObj.pausedByAll = false;		_soundsDict[name] = sndObj;		_sounds.push(sndObj);		return true;	}	/**	 * //TODO	 * Добавляет звук зашитый в timeline swf файла	 * @param name	 * @param url	 * @param type	 * @return	 *	 */	public function addSwfSound(name:String, url:String, type:int = 0):Boolean	{		return true;	}	protected function onLoadError(event:ErrorEvent):void	{		Logger.error(this, "::onLoadError ",event.text);	}	/**	 * Removes a sound from the sound dictionary.  After calling this, the sound will not be available until it is re-added.	 *	 * @param name The string identifier of the sound to remove	 *	 * @return void	 */	public function removeSound(name:String):void	{		for (var i:int = 0; i < this._sounds.length; i++)		{			if (this._sounds[i].name == name)			{				this._sounds[i] = null;				this._sounds.splice(i, 1);			}		}		delete this._soundsDict[name];	}	/**	 * Removes all sounds from the sound dictionary.	 *	 * @return void	 */	public function removeAllSounds():void	{		for (var i:int = 0; i < this._sounds.length; i++)		{			this._sounds[i] = null;		}		this._sounds = new Array();		this._soundsDict = new Dictionary(true);	}	/**	 * Plays or resumes a sound from the sound dictionary with the specified name.	 *	 * @param name The string identifier of the sound to play	 * @param volume A number from 0 to 1 representing the volume at which to play the sound (default: 1)	 * @param startTime A number (in milliseconds) representing the time to start playing the sound at (default: 0)	 * @param loops An integer representing the number of times to loop the sound (default: 0)	 * @param replaceIfPlaying An boolean representing stop now playing sound with same name and start new (default: false)	 * @param dontPlayIfPlaying An boolean representing dont stop now playing sound with same name and dont start new (default: false)	 *	 * @return void	 */	public function playSound(name:String, volume:Number = 1, startTime:Number = 0, loops:int = 0, replaceIfPlaying:Boolean = false, dontPlayIfPlaying:Boolean = false):SoundChannel	{		if(_muted || !available)			return null;		var snd:Object = _soundsDict[name];		if(snd)		{			snd.volume = volume;			snd.startTime = startTime;			snd.loops = loops;			var sound:Sound = snd.sound;			//Logger.debug(this, "::playSound, sound \""+name+"\", volume = "+volume);			try			{				if (snd.paused)				{					snd.channel = sound.play(snd.position, snd.loops, new SoundTransform(snd.volume));				}				else				{					if (replaceIfPlaying)						(snd.channel as SoundChannel).stop();					if (dontPlayIfPlaying && Math.abs((snd.channel as SoundChannel).position - sound.length)/1000 > .5)					{											}					else						snd.channel = sound.play(startTime, snd.loops, new SoundTransform(snd.volume));				}				//пока сомтрим на доступность звука в системе так, т.к. параметр				//Capabilities.hasAudio выставляется в true даже с отключенной звуковой картой				_available = snd.channel != null;			}catch(error:Error)			{				Logger.error(this, "playSound : "+name+" ("+sound.url+")\r"+error.message);			}			snd.paused = false;			return snd.channel;		}else		{			Logger.warning(this, "::playSound, sound \""+name+"\" not found in library");			return null;		}	}	/**	 * Stops the specified sound.	 *	 * @param name The string identifier of the sound	 *	 * @return void	 */	public function stopSound(name:String):void	{		var snd:Object = this._soundsDict[name];		snd.paused = true;		snd.channel.stop();		snd.position = snd.channel.position;	}	/**	 * Pauses the specified sound.	 *	 * @param name The string identifier of the sound	 *	 * @return void	 */	public function pauseSound(name:String):void	{		var snd:Object = this._soundsDict[name];		snd.paused = true;		snd.position = snd.channel.position;		snd.channel.stop();	}	/**	 * Stops all the sounds that are in the sound dictionary.	 *	 * @param useCurrentlyPlayingOnly A boolean that only stops the sounds which are currently playing (default: true)	 *	 * @return void	 */	public function stopAllSounds(useCurrentlyPlayingOnly:Boolean = true):void	{		for (var i:int = 0; i < this._sounds.length; i++)		{			var id:String = this._sounds[i].name;			if (useCurrentlyPlayingOnly)			{				if (!this._soundsDict[id].paused)				{					this._soundsDict[id].pausedByAll = true;					this.stopSound(id);				}			}			else			{				this.stopSound(id);			}		}	}	/**	 * Pauses all the sounds that are in the sound dictionary.	 *	 * @param useCurrentlyPlayingOnly A boolean that only pauses the sounds which are currently playing (default: true)	 *	 * @return void	 */	public function pauseAllSounds(useCurrentlyPlayingOnly:Boolean = true):void	{		for (var i:int = 0; i < this._sounds.length; i++)		{			var id:String = this._sounds[i].name;			if (useCurrentlyPlayingOnly)			{				if (!this._soundsDict[id].paused)				{					this._soundsDict[id].pausedByAll = true;					this.pauseSound(id);				}			}			else			{				this.pauseSound(id);			}		}	}	/**	 * Fades the sound to the specified volume over the specified amount of time.	 *	 * @param name The string identifier of the sound	 * @param $targVolume The target volume to fade to, between 0 and 1 (default: 0)	 * @param $fadeLength The time to fade over, in seconds (default: 1)	 *	 * @return void	 */	public function fadeSound(name:String, targVolume:Number = 0, fadeLength:Number = 1, onComplete:Function = null):GTween	{		if(!_soundsDict[name] || !available)			return null;		var fadeChannel:SoundChannel = _soundsDict[name].channel;		if(fadeChannel && fadeChannel.soundTransform.volume != targVolume)		{			SoundTransformPlugin.install();			var tween:GTween = new GTween(fadeChannel, fadeLength, {volume: targVolume});			//listen tween complete if targVolume==0 to stop the sound			if(targVolume == 0)			{				tween.dispatchEvents = true;				if(onComplete is Function)					tween.addEventListener("complete", onComplete, false, 0, true);				tween.onComplete = onFadeComplete;			}			return tween;		}		return null;	}	/**	 * stop the sound on fade complete	 * @param tween	 *	 */	protected function onFadeComplete(tween:GTween):void	{		var fadeChannel:SoundChannel = tween.target as SoundChannel;		if(fadeChannel)			fadeChannel.stop();	}	protected var _muted:Boolean = false;	/**	 * Mutes the volume for all sounds in the sound dictionary.	 *	 * @return void	 */	public function muteAllSounds(fade:Boolean = true):void	{		_muted = true;		if(!fade)			volume = 0;		else		{			for (var i:int = 0; i < _sounds.length; i++)			{				var id:String = _sounds[i].name;				this.fadeSound(id, 0);			}		}	}	public function unMuteAllSounds(fade:Boolean = true):void	{		_muted = false;	}	/**	 * Resets the volume to their original setting for all sounds in the sound dictionary.	 *	 * @return void	 *///	public function unmuteAllSounds():void//	{//		for (var i:int = 0; i < this._sounds.length; i++)//		{//			var id:String = this._sounds[i].name;//			var snd:Object = this._soundsDict[id];//			var curTransform:SoundTransform = snd.channel.soundTransform;//			curTransform.volume = snd.volume;//			snd.channel.soundTransform = curTransform;//		}//	}	/**	 * Sets the volume of the specified sound.	 *	 * @param $name The string identifier of the sound	 * @param volume The volume, between 0 and 1, to set the sound to	 *	 * @return void	 */	public function setSoundVolume(name:String, volume:Number):void	{		var snd:Object = this._soundsDict[name];		if (snd)		{			snd.volume = volume;			var curTransform:SoundTransform = snd.channel.soundTransform;			curTransform.volume = volume;			snd.channel.soundTransform = curTransform;		}	}	private var _volume:Number = 1;	/**	 * Sets the global volume.	 *	 * @param name The string identifier of the sound	 * @param volume The volume, between 0 and 1, to set the sound to	 *	 * @return void	 */	public function set volume(value:Number):void	{		_volume = value;		for (var i:int = 0; i < this._sounds.length; i++)		{			var id:String = this._sounds[i].name;			this.setSoundVolume(id, _volume);		}	}	public function get volume():Number	{		return _volume;	}}}